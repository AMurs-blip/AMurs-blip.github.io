<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Volume Shader Troll — Enhanced</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        color: #fff;
        font-family: system-ui, Segoe UI, Roboto;
      }
      #ui {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 20;
        padding: 10px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(6px);
      }
      label {
        display: block;
        font-size: 13px;
        margin-bottom: 6px;
      }
      input[type="range"] {
        width: 200px;
      }
      button {
        margin-top: 6px;
        padding: 6px 10px;
        border-radius: 6px;
        border: 0;
        background: #1e88e5;
        color: #fff;
        cursor: pointer;
      }
      button.warn {
        background: #e53935;
      }
      .small {
        font-size: 12px;
        opacity: 0.9;
      }
      #credits {
        position: fixed;
        right: 10px;
        bottom: 8px;
        font-size: 12px;
        opacity: 0.7;
        z-index: 10;
      }
      #fpsBox {
        margin-top: 8px;
        font-family: monospace;
      }
      #modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        z-index: 50;
        visibility: hidden;
      }
      #modal .card {
        background: #111;
        padding: 18px;
        border-radius: 10px;
        max-width: 360px;
        text-align: center;
      }
      #fakeFPS {
        color: #ffb86b;
      }
      #realFPS {
        color: #8be9fd;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <label>Quality (steps): <span id="qval">64</span></label>
      <input id="quality" type="range" min="8" max="128" value="64" />
      <div style="height: 6px"></div>

      <label
        ><input id="lowBatteryFriendly" type="checkbox" /> Low-battery friendly
        (auto reduce on phones)</label
      >
      <label
        ><input id="fakeIncompat" type="checkbox" checked /> Show "Device
        incompatible" fake modal first</label
      >

      <div id="fpsBox">
        <div>Fake FPS: <span id="fakeFPS">60</span></div>
        <div>Real FPS: <span id="realFPS">--</span></div>
      </div>

      <div style="height: 6px"></div>
      <button id="full">Fullscreen</button>
      <button id="stop" class="warn">STOP</button>
      <button id="soundBtn">Enable Sound (required)</button>
      <div style="height: 6px"></div>
      <small class="small"
        >Warning: heavy GPU load. Use responsibly. STOP will halt rendering &
        sound.</small
      >
    </div>

    <div id="credits">Volume Shader Demo — enhanced troll kit</div>

    <!-- fake "incompatible" modal (opt-in) -->
    <div id="modal">
      <div class="card">
        <h3>Device incompatible</h3>
        <p>
          Your device model appears incompatible with this demo.<br />Tap
          <strong>Run Anyway</strong> to continue or Cancel to leave.
        </p>
        <div style="height: 10px"></div>
        <button id="runAnyway">Run Anyway</button>
        <button id="cancelRun" class="warn">Cancel</button>
      </div>
    </div>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
      /* ========= CONFIG & UNIFORMS ========= */
      let renderer, scene, camera, material, mesh, animationId;
      const clock = new THREE.Clock();
      const uniforms = {
        iTime: { value: 0 },
        iResolution: { value: new THREE.Vector2() },
        quality: { value: 64.0 },
        stop: { value: 0 },
        rainbow: { value: 0.0 },
      };

      /* ========= FRAGMENT SHADER (volumetric + rainbow toggle) ========= */
      const fs = `precision highp float;
uniform vec2 iResolution;
uniform float iTime;
uniform float quality;
uniform float stop;
uniform float rainbow;

highp float hash(highp vec3 p){
  p = fract(p * 0.3183099 + 0.1);
  p *= 17.0;
  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}
float noise(vec3 x){
  vec3 p = floor(x);
  vec3 f = fract(x);
  f = f*f*(3.0-2.0*f);
  float n = mix(mix(mix(hash(p + vec3(0,0,0)), hash(p + vec3(1,0,0)), f.x),
                    mix(hash(p + vec3(0,1,0)), hash(p + vec3(1,1,0)), f.x), f.y),
                mix(mix(hash(p + vec3(0,0,1)), hash(p + vec3(1,0,1)), f.x),
                    mix(hash(p + vec3(0,1,1)), hash(p + vec3(1,1,1)), f.x), f.y), f.z);
  return n;
}
float fbm(vec3 p){
  float a = 0.0;
  float w = 0.5;
  for(int i=0;i<5;i++){
    a += w * noise(p);
    p *= 2.0;
    w *= 0.5;
  }
  return a;
}

vec3 palette(float t){
  // base blue fog
  vec3 col = vec3(0.25, 0.45, 0.85) * (0.6 + 0.4 * t);
  if(rainbow > 0.5){
    // rainbow overlay using sin waves
    col = 0.5 + 0.5 * cos(6.2831 * (t + vec3(0.0,0.33,0.66)));
  }
  return col;
}

vec4 render(vec2 uv){
  vec3 ro = vec3(0.0, 0.0, -2.0);
  vec3 rd = normalize(vec3(uv.xy, 1.5));
  float t = 0.0;
  float steps = max(8.0, quality);
  float dt = 0.02 + (1.0/steps) * 0.25;
  vec3 col = vec3(0.0);
  float a = 0.0;
  for(float i=0.0; i<512.0; i++){
    if(i>steps) break;
    vec3 p = ro + rd * t;
    float d = fbm(p * 1.2 + vec3(0.0, iTime*0.08, 0.0));
    float dens = smoothstep(0.45, 0.7, d) * 1.2;
    float light = clamp((0.6 + 0.4 * fbm(p*0.6 + vec3(5.0))), 0.0, 1.0);
    vec3 sample = palette(d) * dens * light;
    float alpha = 1.0 - exp(-dens * 0.6);
    col = col + (1.0 - a) * sample * alpha;
    a += (1.0 - a) * alpha;
    t += dt;
    if(a>0.98) break;
    if(stop > 0.5) break;
  }
  col = 1.0 - exp(-col);
  return vec4(col, 1.0);
}

void main(){
  if(stop > 0.5){ gl_FragColor = vec4(0.0); return; }
  vec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;
  uv.x *= iResolution.x / iResolution.y;
  vec4 c = render(uv);
  gl_FragColor = c;
}`;

      function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        material = new THREE.ShaderMaterial({
          fragmentShader: fs,
          uniforms,
          depthWrite: false,
        });

        const geom = new THREE.PlaneGeometry(2, 2);
        mesh = new THREE.Mesh(geom, material);
        scene.add(mesh);

        onWindowResize();
        window.addEventListener("resize", onWindowResize);
        animate();
      }

      /* ========= ADAPTIVE HELPERS: mobile detect, battery API, auto quality reduction ========= */
      const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
      const lowBatteryCheckbox = document.getElementById("lowBatteryFriendly");
      let batteryObj = null;
      if (navigator.getBattery) {
        navigator.getBattery().then((b) => {
          batteryObj = b;
          watchBattery();
        });
      }
      function watchBattery() {
        if (!batteryObj) return;
        batteryObj.addEventListener("levelchange", applyBatteryPolicy);
        batteryObj.addEventListener("chargingchange", applyBatteryPolicy);
        applyBatteryPolicy();
      }
      function applyBatteryPolicy() {
        if (!batteryObj) return;
        // if low battery and user wants lowBatteryFriendly => reduce quality aggressively
        if (lowBatteryCheckbox.checked && batteryObj.level !== undefined) {
          if (!batteryObj.charging && batteryObj.level < 0.35) {
            uniforms.quality.value = 12.0;
            document.getElementById("quality").value = 12;
            document.getElementById("qval").textContent = 12;
          }
        }
        // also auto reduce on phones if checked
        if (lowBatteryCheckbox.checked && isMobile) {
          uniforms.quality.value = 20.0;
          document.getElementById("quality").value = 20;
          document.getElementById("qval").textContent = 20;
        }
      }

      /* ========= ANIMATION LOOP + REAL FPS MEASURER ========= */
      let lastFrame = performance.now(),
        frameCount = 0,
        fpsSmoother = 60;
      function animate(now) {
        animationId = requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        uniforms.iTime.value = t;
        renderer.render(scene, camera);

        // real FPS measurement
        const delta = (now - lastFrame) / 1000;
        lastFrame = now;
        const instantFPS = 1 / Math.max(0.0001, delta);
        fpsSmoother = fpsSmoother * 0.92 + instantFPS * 0.08;
        document.getElementById("realFPS").textContent =
          Math.round(fpsSmoother);

        // fake FPS display logic handled elsewhere (separate timer)
      }

      /* ========= FAKE FPS: simulate drop to troll friend ========= */
      let fakeFPSValue = 60;
      function startFakeFPSRoutine() {
        // If user reduces quality, fakefps should reflect (for plausibility)
        const qInput = document.getElementById("quality");
        const adjustFake = () => {
          const q = Number(qInput.value);
          // map quality 8..128 => fake fps baseline 10..120 (inverted slightly)
          fakeFPSValue = Math.max(8, Math.round(140 - q));
          document.getElementById("fakeFPS").textContent = fakeFPSValue;
        };
        qInput.addEventListener("input", () => {
          uniforms.quality.value = Number(qInput.value);
          document.getElementById("qval").textContent = qInput.value;
          adjustFake();
        });
        // initial set
        adjustFake();
        // periodic small random jitter to feel realistic
        setInterval(() => {
          const jitter = Math.random() * 6 - 3;
          document.getElementById("fakeFPS").textContent = Math.max(
            1,
            Math.round(fakeFPSValue + jitter)
          );
        }, 900);
      }

      /* ========= FAKE "DEVICE INCOMPATIBLE" MODAL ========= */
      const modal = document.getElementById("modal");
      function showFakeModalIfNeeded() {
        if (!document.getElementById("fakeIncompat").checked) return startApp();
        // show modal with option to "Run Anyway" (opt-in)
        modal.style.visibility = "visible";
        document.getElementById("runAnyway").onclick = () => {
          modal.style.visibility = "hidden";
          startApp();
        };
        document.getElementById("cancelRun").onclick = () => {
          modal.style.visibility = "hidden";
          // friendly stop: don't start the demo
          // show a simple message and keep canvas off
          alert("Okay, demo cancelled.");
        };
      }

      /* ========= SOUND (blaring) + EASTER EGG (rainbow toggle) ========= */
      let audioCtx, oscillator, soundGain;
      let soundAllowed = false;
      const soundBtn = document.getElementById("soundBtn");
      soundBtn.addEventListener("click", () => {
        // create small blaring sound source; browsers require user gesture to unlock audio
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          oscillator = audioCtx.createOscillator();
          soundGain = audioCtx.createGain();
          oscillator.type = "sawtooth";
          oscillator.frequency.value = 200; // base; will boost when triggered
          soundGain.gain.value = 0.0;
          oscillator.connect(soundGain).connect(audioCtx.destination);
          oscillator.start();
        }
        soundAllowed = true;
        soundBtn.textContent = "Sound enabled";
        soundBtn.disabled = true;
      });

      // function to trigger blaring sound (requires user gesture previously enabled)
      function blare() {
        if (!soundAllowed || !audioCtx) return;
        // ramp up gain quickly then fade
        soundGain.gain.cancelScheduledValues(audioCtx.currentTime);
        soundGain.gain.setValueAtTime(0.0, audioCtx.currentTime);
        soundGain.gain.linearRampToValueAtTime(
          0.5,
          audioCtx.currentTime + 0.05
        );
        oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
        setTimeout(() => {
          soundGain.gain.linearRampToValueAtTime(
            0.0,
            audioCtx.currentTime + 0.8
          );
          oscillator.frequency.setValueAtTime(200, audioCtx.currentTime + 0.8);
        }, 400);
      }

      /* Easter egg: press R to toggle rainbow, press S to blare (sound must be enabled) */
      window.addEventListener("keydown", (e) => {
        if (e.key === "r" || e.key === "R") {
          uniforms.rainbow.value = uniforms.rainbow.value > 0.5 ? 0.0 : 1.0;
        } else if (e.key === "s" || e.key === "S") {
          blare();
        }
      });

      /* ========= UI Wiring: fullscreen, stop, start ========= */
      document.getElementById("full").addEventListener("click", () => {
        const el = renderer ? renderer.domElement : document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen();
      });
      document.getElementById("stop").addEventListener("click", () => {
        uniforms.stop.value = 1.0;
        if (animationId) cancelAnimationFrame(animationId);
        if (renderer && renderer.domElement)
          renderer.domElement.style.filter = "brightness(.12)";
        // stop audio if playing
        if (soundGain)
          soundGain.gain.cancelScheduledValues(
            audioCtx ? audioCtx.currentTime : 0
          );
        alert("Stopped. Don't be a jerk.");
      });

      /* ========= START APP (after modal decisions) ========= */
      function startApp() {
        init();
        startFakeFPSRoutine();
        // if lowBatteryFriendly is checked, apply immediately
        applyBatteryPolicy();
        // if mobile and lowBatteryFriendly not checked, we can still auto reduce for plausibility
        if (isMobile && !lowBatteryCheckbox.checked) {
          // reduce but not too low so demo still heavy
          uniforms.quality.value = Math.min(uniforms.quality.value, 32);
          document.getElementById("quality").value = uniforms.quality.value;
          document.getElementById("qval").textContent = uniforms.quality.value;
        }
        // small safety: if user is on very weak device, reduce steps to avoid freeze (prevents bricking)
        const w = window.innerWidth,
          h = window.innerHeight;
        if (w * h < 400000) {
          // tiny screens -> be kinder
          uniforms.quality.value = Math.min(uniforms.quality.value, 36);
          document.getElementById("quality").value = uniforms.quality.value;
          document.getElementById("qval").textContent = uniforms.quality.value;
        }
        // start an optional autoplay "troll" sequence: slowly lower fake FPS display over 15s
        let dec = 0;
        const decInterval = setInterval(() => {
          dec++;
          // nudge fakeFPS down for drama
          fakeFPSValue = Math.max(6, fakeFPSValue - 1);
          if (dec > 18) clearInterval(decInterval);
        }, 900);
      }

      /* ========= KILL & CLEANUP ON NAV AWAY ========= */
      window.addEventListener("beforeunload", () => {
        if (animationId) cancelAnimationFrame(animationId);
        if (renderer) renderer.dispose();
        if (audioCtx) audioCtx.close();
      });

      /* ========= BOOT: show modal if opted, else start ========= */
      showFakeModalIfNeeded();

      /* ========= Allow user to toggle fakeIncompat checkbox before modal; if unchecked, auto-start after short delay ========= */
      if (!document.getElementById("fakeIncompat").checked) {
        setTimeout(() => {
          if (!animationId) startApp();
        }, 300);
      }

      /* ========= Begin real-time battery watcher if available ========= */
      if (batteryObj) watchBattery();

      /* ========= Initial fake FPS jitter start even before demo (for UI plausibility) ========= */
      setTimeout(() => {
        startFakeFPSRoutine();
      }, 200);

      /* ========= OPTIONAL: small polite fallback message if WebGL unsupported ========= */
      if (!window.WebGLRenderingContext) {
        alert(
          "Your browser does not support WebGL/canvas. Use Chrome/Firefox/Edge on desktop or modern mobile browser."
        );
      }
    </script>
  </body>
</html>
